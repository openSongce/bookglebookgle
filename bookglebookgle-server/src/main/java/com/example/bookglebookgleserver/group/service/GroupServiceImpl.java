package com.example.bookglebookgleserver.group.service;

import com.bgbg.ai.grpc.AIServiceProto.ProcessPdfResponse;
import com.example.bookglebookgleserver.chat.entity.ChatRoom;
import com.example.bookglebookgleserver.chat.entity.ChatRoomMember;
import com.example.bookglebookgleserver.chat.repository.ChatRoomMemberRepository;
import com.example.bookglebookgleserver.chat.repository.ChatRoomRepository;
import com.example.bookglebookgleserver.fcm.service.GroupNotificationScheduler;
import com.example.bookglebookgleserver.fcm.util.KoreanScheduleParser;
import com.example.bookglebookgleserver.global.exception.BadRequestException;
import com.example.bookglebookgleserver.global.exception.ForbiddenException;
import com.example.bookglebookgleserver.global.exception.NotFoundException;
import com.example.bookglebookgleserver.group.dto.*;
import com.example.bookglebookgleserver.group.entity.Group;
import com.example.bookglebookgleserver.group.entity.GroupMember;
import com.example.bookglebookgleserver.group.repository.GroupMemberRatingRepository;
import com.example.bookglebookgleserver.group.repository.GroupMemberRepository;
import com.example.bookglebookgleserver.group.repository.GroupRepository;
import com.example.bookglebookgleserver.ocr.dto.OcrTextBlockDto;
import com.example.bookglebookgleserver.ocr.grpc.GrpcOcrClient;
import com.example.bookglebookgleserver.ocr.service.OcrService;
import com.example.bookglebookgleserver.pdf.entity.PdfFile;
import com.example.bookglebookgleserver.pdf.repository.PdfFileRepository;
import com.example.bookglebookgleserver.pdf.util.PdfUtils;
import com.example.bookglebookgleserver.user.entity.User;
import com.example.bookglebookgleserver.user.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.support.CronTrigger;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.servlet.mvc.method.annotation.StreamingResponseBody;

import java.io.File;
import java.io.IOException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class GroupServiceImpl implements GroupService {

    private final GroupRepository groupRepository;
    private final GroupMemberRepository groupMemberRepository;
    private final PdfFileRepository pdfFileRepository;
    private final GrpcOcrClient grpcOcrClient;
    private final OcrService ocrService;
    private final UserRepository userRepository;
    private final ChatRoomRepository chatRoomRepository;
    private final ChatRoomMemberRepository chatRoomMemberRepository;
    private final GroupNotificationScheduler groupNotificationScheduler;
    private final GroupMemberRatingRepository groupMemberRatingRepository;

    private static final TimeZone TZ = TimeZone.getTimeZone("Asia/Seoul");

    @Override
    @Transactional
    public GroupCreateResponseDto createGroup(GroupCreateRequestDto dto, MultipartFile pdfUpload, User user) {
        String uploadDir = "/home/ubuntu/pdf-uploads/";
        File uploadDirFile = new File(uploadDir);
        if (!uploadDirFile.exists()) uploadDirFile.mkdirs();

        String storedFileName = UUID.randomUUID() + "_" + pdfUpload.getOriginalFilename();
        String filePath = uploadDir + storedFileName;

        try {
            pdfUpload.transferTo(new File(filePath));
        } catch (IOException e) {
            throw new BadRequestException("PDF ÌååÏùº Ï†ÄÏû• Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
        }

        PdfFile pdf = PdfFile.builder()
                .fileName(pdfUpload.getOriginalFilename())
                .pageCnt(0)
                .uploadUser(user)
                .createdAt(LocalDateTime.now())
                .filePath(filePath)
                .imageBased(dto.isImageBased())
                .hasOcr(false)
                .build();
        pdfFileRepository.save(pdf);

        int pageCount = PdfUtils.getPageCount(filePath);
        pdf.setPageCnt(pageCount);
        pdfFileRepository.save(pdf);
        log.info("üìÑ PDF ÌéòÏù¥ÏßÄ Ïàò Ï∂îÏ∂ú ÏôÑÎ£å: {} ÌéòÏù¥ÏßÄ", pageCount);

        // Ïä§ÏºÄÏ§Ñ CRON Î≥ÄÌôò
        String cron = null;
        if (dto.getSchedule() != null && !dto.getSchedule().isBlank()) {
            try {
                try { new CronTrigger(dto.getSchedule(), TZ); cron = dto.getSchedule(); }
                catch (Exception ignore) { cron = KoreanScheduleParser.toCron(dto.getSchedule()); }
            } catch (Exception e) {
                log.warn("‚ö†Ô∏è Í∑∏Î£π Ïä§ÏºÄÏ§Ñ ÌååÏã± Ïã§Ìå®: ÏûÖÎ†•='{}', reason={}. Ïä§ÏºÄÏ§Ñ ÏóÜÏù¥ ÏÉùÏÑ±.", dto.getSchedule(), e.getMessage());
            }
        }

        Group group = Group.builder()
                .roomTitle(dto.getRoomTitle())
                .description(dto.getDescription())
                .category(Group.Category.valueOf(dto.getCategory().toUpperCase()))
                .minRequiredRating(dto.getMinRequiredRating())
                .schedule(cron)
                .groupMaxNum(dto.getGroupMaxNum())
                .readingMode(Group.ReadingMode.valueOf(dto.getReadingMode().toUpperCase()))
                .hostUser(user)
                .pdfFile(pdf)
                .totalPages(pageCount)
                .createdAt(LocalDateTime.now())
                .updatedAt(LocalDateTime.now())
                .isDeleted(false)
                .build();
        groupRepository.save(group);

        if (cron != null) {
            try {
                groupNotificationScheduler.register(group.getId(), cron);
            } catch (Exception e) {
                log.warn("‚ö†Ô∏è Ïä§ÏºÄÏ§Ñ Îì±Î°ù Ïã§Ìå®: groupId={}, cron='{}', reason={}", group.getId(), cron, e.getMessage());
            }
        }

        pdf.setGroup(group);

        List<OcrTextBlockDto> ocrResultList = List.of();

        // ‚úÖ OCR Ï≤òÎ¶¨ Î∂ÑÍ∏∞
        if (dto.isImageBased()) {
            ProcessPdfResponse response = grpcOcrClient.sendPdf(pdf.getPdfId(), pdfUpload, group.getId());
            if (!response.getSuccess()) {
                log.warn("‚ùå OCR Ïã§Ìå®: {}", response.getMessage());
                throw new BadRequestException("OCR Ïã§Ìå®: " + response.getMessage());
            }
            ocrService.saveOcrResults(pdf, response);
            pdf.setHasOcr(true);
            pdfFileRepository.save(pdf);

            ocrResultList = response.getTextBlocksList().stream()
                    .map(block -> OcrTextBlockDto.builder()
                            .pageNumber(block.getPageNumber())
                            .text(block.getText())
                            .rectX(block.getX0())
                            .rectY(block.getY0())
                            .rectW((block.getX1() - block.getX0()))
                            .rectH((block.getY1() - block.getY0()))
                            .build())
                    .collect(Collectors.toList());
        } else {
            grpcOcrClient.sendPdfNoOcr(pdf.getPdfId(), pdfUpload, group.getId());
        }

        ChatRoom chatRoom = ChatRoom.builder()
                .group(group)
                .category(group.getCategory().name())
                .groupTitle(group.getRoomTitle())
                .imageUrl(null)
                .lastMessage(null)
                .lastMessageTime(null)
                .memberCount(1)
                .build();
        chatRoomRepository.save(chatRoom);

        ChatRoomMember chatRoomMember = ChatRoomMember.builder()
                .chatRoom(chatRoom)
                .user(user)
                .build();
        chatRoomMemberRepository.save(chatRoomMember);

        GroupMember groupMember = GroupMember.builder()
                .group(group)
                .user(user)
                .isHost(true)
                .maxReadPage(0)
                .progressPercent(0f)
                .isFollowingHost(false)
                .build();
        groupMemberRepository.save(groupMember);

        return GroupCreateResponseDto.builder()
                .groupId(group.getId())
                .pdfId(pdf.getPdfId())
                .ocrResultlist(ocrResultList)
                .build();
    }

    @Override
    public List<GroupListResponseDto> getNotJoinedGroupList(Long userId) {
        List<Group> groups = groupRepository.findAll();
        List<Long> joinedGroupIds = groupMemberRepository.findGroupIdsByUserId(userId);

        return groups.stream()
                .filter(group -> !joinedGroupIds.contains(group.getId()))
                .map(group -> {
                    int currentNum = groupMemberRepository.countByGroup(group);
                    return GroupListResponseDto.builder()
                            .groupId(group.getId())
                            .roomTitle(group.getRoomTitle())
                            .description(group.getDescription())
                            .category(group.getCategory().name())
                            .groupMaxNum(group.getGroupMaxNum())
                            .currentNum(currentNum)
                            .minimumRating(group.getMinRequiredRating())
                            .build();
                })
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public GroupDetailResponse getGroupDetail(Long groupId, User requester) {
        Group group = groupRepository.findById(groupId)
                .orElseThrow(() -> new NotFoundException("Ìï¥Îãπ Î™®ÏûÑÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§."));

        int pageCount = resolvePageCount(group);
        boolean requesterIsHost = group.getHostUser().getId().equals(requester.getId());

        // Í∏∞Î≥∏ Î©§Î≤Ñ Ï†ïÎ≥¥
        List<GroupMemberDetailDto> base = groupMemberRepository.findMemberDetailsByGroupId(groupId);
        // 2) (from‚Üíto) Î≤åÌÅ¨ Ï°∞Ìöå ÌõÑ Map<Long, List<Long>>Î°ú Î≥ÄÌôò
        List<Object[]> pairs = groupMemberRatingRepository.findAllFromToPairsByGroupId(groupId);
        Map<Long, List<Long>> fromToMap = pairs.stream()
                .collect(Collectors.groupingBy(
                        row -> (Long) row[0],                                   // fromUserId
                        Collectors.mapping(row -> (Long) row[1],                // toUserId
                                Collectors.collectingAndThen(Collectors.toList(), list -> {
                                    // Ï§ëÎ≥µ Ï†úÍ±∞ + Î∂àÎ≥Ä Î¶¨Ïä§Ìä∏
                                    return List.copyOf(new LinkedHashSet<>(list));
                                }))
                ));

        long otherMembersCountIfAll = Math.max(0, base.size() - 1);

        // 3) DTOÏóê ratedUserIds / ratingSubmitted / progressPercent Ï£ºÏûÖ
        List<GroupMemberDetailDto> members = base.stream().map(m -> {
            int progressPercent = calcProgressPercent(m.maxReadPage(), pageCount);

            List<Long> ratedUserIds = fromToMap.getOrDefault(m.userId(), Collections.emptyList());
            boolean ratingSubmitted = (otherMembersCountIfAll > 0) && (ratedUserIds.size() == otherMembersCountIfAll);

            return new GroupMemberDetailDto(
                    m.userId(),
                    m.userNickName(),
                    m.profileColor(),
                    m.maxReadPage(),
                    progressPercent,
                    m.isHost(),
                    m.profileImageUrl(),
                    ratingSubmitted,
                    ratedUserIds
            );
        }).toList();

        boolean allMemberCompleted = !members.isEmpty() &&
                members.stream().allMatch(mm -> mm.progressPercent() >= 100);

        String readableSchedule = cronToReadable(group.getSchedule());

        return new GroupDetailResponse(
                group.getRoomTitle(),
                group.getCategory().name(),
                readableSchedule,
                members.size(),
                group.getGroupMaxNum(),
                group.getDescription(),
                null,
                requesterIsHost,
                group.getMinRequiredRating(),
                pageCount,
                members,
                allMemberCompleted
        );
    }





    // (Ìò∏Ìôò) PDFÎßå Î∞òÌôò
    @Override
    public ResponseEntity<Resource> getPdfFileResponse(Long groupId, User user) {
        if (!groupMemberRepository.isMember(groupId, user.getId())) {
            throw new ForbiddenException("Ìï¥Îãπ Í∑∏Î£πÏóê ÏÜçÌï¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§.");
        }

        PdfFile pdfFile = pdfFileRepository.findByGroup_Id(groupId)
                .orElseThrow(() -> new NotFoundException("PDF ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§."));

        File file = new File(pdfFile.getFilePath());
        if (!file.exists()) {
            throw new NotFoundException("ÏÑúÎ≤ÑÏóê PDF ÌååÏùºÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.");
        }


        // UTF-8 Î∞îÏù¥Ìä∏Î•º ÏßÅÏ†ë Ìó§ÎçîÏóê ÎÑ£Í∏∞ (Í∞ÄÏû• Ìò∏ÌôòÏÑ± Ï¢ãÏùå)
        String raw = pdfFile.getFileName();
        String cd = "inline; filename*=UTF-8''" + URLEncoder.encode(raw, StandardCharsets.UTF_8);

        return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_PDF)
                .header("Content-Disposition", cd)
                .header("X-OCR-Available", String.valueOf(pdfFile.isHasOcr()))
                .body(new FileSystemResource(file));

//        return ResponseEntity.ok()
//                .contentType(MediaType.APPLICATION_PDF)
//                .header("Content-Disposition", "inline; filename=\"" + pdfFile.getFileName() + "\"")
//                .header("X-OCR-Available", String.valueOf(pdfFile.isHasOcr()))
//                .body(new FileSystemResource(file));
    }

    // ‚úÖ Accept Ìó§Îçî Í∏∞Î∞ò: PDF ÌòπÏùÄ ZIP

    // after
    @Override
    public ResponseEntity<StreamingResponseBody> getPdfResponse(Long groupId, User user, String accept) {
        if (!groupMemberRepository.isMember(groupId, user.getId())) {
            throw new ForbiddenException("Ìï¥Îãπ Í∑∏Î£πÏóê ÏÜçÌï¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§.");
        }

        PdfFile pdfFile = pdfFileRepository.findByGroup_Id(groupId)
                .orElseThrow(() -> new NotFoundException("PDF ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§."));

        boolean wantZip = wantsZip(accept);
        boolean hasOcr = pdfFile.isHasOcr();

        if (wantZip && hasOcr) {
            return getPdfAndOcrZip(groupId, user); // Ïù¥ÎØ∏ StreamingResponseBody Î∞òÌôò
        }

        File file = new File(pdfFile.getFilePath());
        if (!file.exists()) throw new NotFoundException("ÏÑúÎ≤ÑÏóê PDF ÌååÏùºÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.");

        // UTF-8 Î∞îÏù¥Ìä∏Î•º ÏßÅÏ†ë Ìó§ÎçîÏóê ÎÑ£Í∏∞ (Í∞ÄÏû• Ìò∏ÌôòÏÑ± Ï¢ãÏùå)
        String raw = pdfFile.getFileName();
        String cd = "inline; filename*=UTF-8''" + URLEncoder.encode(raw, StandardCharsets.UTF_8);

        StreamingResponseBody body = outputStream -> {
            try (java.io.FileInputStream in = new java.io.FileInputStream(file)) {
                in.transferTo(outputStream);
                outputStream.flush();
            }
        };
        return ResponseEntity.ok()
                .contentType(MediaType.APPLICATION_PDF)
                .header("Content-Disposition", cd)
                .header("X-OCR-Available", String.valueOf(hasOcr))
                .body(body);

//        return ResponseEntity.ok()
//                .contentType(MediaType.APPLICATION_PDF)
//                .header("Content-Disposition", "inline; filename=\"" + filename + "\"")
//                .header("X-OCR-Available", String.valueOf(hasOcr))
//                .body(body);
    }


    @Override
    public ResponseEntity<StreamingResponseBody> getPdfAndOcrZip(Long groupId, User user) {
        if (!groupMemberRepository.isMember(groupId, user.getId())) {
            throw new ForbiddenException("Ìï¥Îãπ Í∑∏Î£πÏóê ÏÜçÌï¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§.");
        }

        PdfFile pdfFile = pdfFileRepository.findByGroup_Id(groupId)
                .orElseThrow(() -> new NotFoundException("PDF ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§."));
        File file = new File(pdfFile.getFilePath());
        if (!file.exists()) throw new NotFoundException("ÏÑúÎ≤ÑÏóê PDF ÌååÏùºÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§.");
        if (!pdfFile.isHasOcr()) throw new BadRequestException("Ìï¥Îãπ PDFÎäî OCR Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.");

        // OCR ÏßÅÎ†¨Ìôî
        var blocks = ocrService.getOcrBlocksByPdfId(pdfFile.getPdfId());
        String ocrJson;
        try {
            ocrJson = new com.fasterxml.jackson.databind.ObjectMapper().writeValueAsString(blocks);
        } catch (Exception e) {
            throw new BadRequestException("OCR ÏßÅÎ†¨Ìôî Ïã§Ìå®: " + e.getMessage());
        }

        StreamingResponseBody body = outputStream -> {
            try (java.util.zip.ZipOutputStream zos = new java.util.zip.ZipOutputStream(outputStream)) {
                // 1) PDF
                zos.putNextEntry(new java.util.zip.ZipEntry("document.pdf"));
                try (java.io.FileInputStream in = new java.io.FileInputStream(file)) {
                    in.transferTo(zos);
                }
                zos.closeEntry();

                // 2) OCR JSON
                zos.putNextEntry(new java.util.zip.ZipEntry("ocr.json"));
                zos.write(ocrJson.getBytes(java.nio.charset.StandardCharsets.UTF_8));
                zos.closeEntry();

                zos.finish();
            }
        };

        // UTF-8 Î∞îÏù¥Ìä∏Î•º ÏßÅÏ†ë Ìó§ÎçîÏóê ÎÑ£Í∏∞
        String zipName = "group-" + groupId + "-pdf-with-ocr.zip";
        String cd = "attachment; filename*=UTF-8''" + URLEncoder.encode(zipName, StandardCharsets.UTF_8);

        return ResponseEntity.ok()
                .contentType(MediaType.parseMediaType("application/zip"))
                .header("Content-Disposition", cd)
                .header("X-OCR-Available", "true")
                .header("X-Accel-Buffering", "no")
                .body(body);
//        return ResponseEntity.ok()
//                .contentType(MediaType.parseMediaType("application/zip"))
//                .header("Content-Disposition", "attachment; filename=\"" + zipName + "\"")
//                .header("X-OCR-Available", "true")
//                // Nginx ÏÇ¨Ïö© Ïãú Î≤ÑÌçºÎßÅ Î∞©ÏßÄ(ÏÑ†ÌÉù): .header("X-Accel-Buffering","no")
//                .body(body);
    }

    private static boolean wantsZip(String accept) {
        if (accept == null || accept.isBlank()) return false;
        try {
            for (var mt : MediaType.parseMediaTypes(accept)) {
                if (mt.isCompatibleWith(MediaType.valueOf("application/zip"))) return true;
            }
        } catch (Exception ignored) {}
        return false;
    }

    private static String safeFilename(String name) {
        if (name == null) return "document";
        return name.replaceAll("[\\r\\n\"]", "_");
    }

    @Override
    @Transactional
    public void joinGroup(Long groupId, User user) {
        Group group = groupRepository.findById(groupId)
                .orElseThrow(() -> new NotFoundException("Ìï¥Îãπ Í∑∏Î£πÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§."));

        if (groupMemberRepository.existsByGroupAndUser(group, user)) {
            throw new BadRequestException("Ïù¥ÎØ∏ Ï∞∏Í∞ÄÌïú Í∑∏Î£πÏûÖÎãàÎã§.");
        }

        int currentNum = groupMemberRepository.countByGroup(group);
        if (currentNum >= group.getGroupMaxNum()) {
            throw new BadRequestException("Í∑∏Î£π Ï†ïÏõêÏù¥ Ï¥àÍ≥ºÎêòÏóàÏäµÎãàÎã§.");
        }

        if (user.getAvgRating() == null || user.getAvgRating() < group.getMinRequiredRating()) {
            throw new BadRequestException("ÌèâÏ†êÏù¥ ÎÇÆÏïÑ Í∑∏Î£πÏóê Ï∞∏Í∞ÄÌï† Ïàò ÏóÜÏäµÎãàÎã§.");
        }

        GroupMember member = GroupMember.builder()
                .group(group)
                .user(user)
                .isHost(false)
                .maxReadPage(0)
                .progressPercent(0f)
                .isFollowingHost(false)
                .build();
        groupMemberRepository.save(member);

        ChatRoom chatRoom = chatRoomRepository.findByGroupId(groupId)
                .orElseThrow(() -> new NotFoundException("Ï±ÑÌåÖÎ∞© ÏóÜÏùå"));

        ChatRoomMember chatMember = ChatRoomMember.builder()
                .chatRoom(chatRoom)
                .user(user)
                .build();
        chatRoomMemberRepository.save(chatMember);

        chatRoom.setMemberCount(chatRoom.getMemberCount() + 1);
        chatRoomRepository.save(chatRoom);

        log.info("[GroupService] userId={} Í∑∏Î£π {} Ï∞∏Í∞Ä Î∞è Ï±ÑÌåÖÎ∞© Î©§Î≤Ñ Ï∂îÍ∞Ä ÏôÑÎ£å, memberCount={}",
                user.getId(), groupId, chatRoom.getMemberCount());
    }

    @Override
    @Transactional
    public GroupDetailResponse updateGroup(Long groupId, GroupUpdateRequestDto dto, User user) {
        Group group = groupRepository.findById(groupId)
                .orElseThrow(() -> new NotFoundException("Ìï¥Îãπ Î™®ÏûÑÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§."));

        if (!group.getHostUser().getId().equals(user.getId())) {
            throw new ForbiddenException("Í∑∏Î£π ÏàòÏ†ï Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.");
        }

        // Í∑∏Î£π Ï†ïÎ≥¥ ÏóÖÎç∞Ïù¥Ìä∏
        if (dto.getRoomTitle() != null) group.setRoomTitle(dto.getRoomTitle());
        if (dto.getDescription() != null) group.setDescription(dto.getDescription());
        if (dto.getCategory() != null) group.setCategory(Group.Category.valueOf(dto.getCategory().toUpperCase()));
        if (dto.getGroupMaxNum() > 0) group.setGroupMaxNum(dto.getGroupMaxNum());
        if (dto.getMinRequiredRating() > 0) group.setMinRequiredRating(dto.getMinRequiredRating());
        if (dto.getReadingMode() != null) group.setReadingMode(Group.ReadingMode.valueOf(dto.getReadingMode().toUpperCase()));

        // Ïä§ÏºÄÏ§Ñ ÏóÖÎç∞Ïù¥Ìä∏
        if (dto.getSchedule() != null) {
            String input = dto.getSchedule();
            if (input.isBlank()) {
                group.setSchedule(null);
                groupNotificationScheduler.unregister(groupId);
                log.info("üóëÔ∏è Í∑∏Î£π Ïä§ÏºÄÏ§Ñ Ìï¥Ï†ú: groupId={}", groupId);
            } else {
                try {
                    String cron;
                    try { new CronTrigger(input, TZ); cron = input; }
                    catch (Exception ignore) { cron = KoreanScheduleParser.toCron(input); }
                    group.setSchedule(cron);
                    groupNotificationScheduler.register(groupId, cron);
                } catch (Exception e) {
                    throw new BadRequestException("Ïä§ÏºÄÏ§Ñ ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§: " + e.getMessage());
                }
            }
        }

        groupRepository.save(group);

        // === ÏùëÎãµ ÏÉùÏÑ± ===
        boolean isHost = group.getHostUser().getId().equals(user.getId());
        int pageCount = resolvePageCount(group);

        // 1) Í∏∞Î≥∏ Î©§Î≤Ñ Ï†ïÎ≥¥
        List<GroupMemberDetailDto> base = groupMemberRepository.findMemberDetailsByGroupId(groupId);

        // 2) (from‚Üíto) Î≤åÌÅ¨ Ï°∞Ìöå ÌõÑ Map<Long, List<Long>>Î°ú Î≥ÄÌôò
        List<Object[]> pairs = groupMemberRatingRepository.findAllFromToPairsByGroupId(groupId);
        Map<Long, List<Long>> fromToMap = pairs.stream()
                .collect(Collectors.groupingBy(
                        row -> (Long) row[0],                                   // fromUserId
                        Collectors.mapping(row -> (Long) row[1],                // toUserId
                                Collectors.collectingAndThen(Collectors.toList(), list -> {
                                    // Ï§ëÎ≥µ Ï†úÍ±∞ + Î∂àÎ≥Ä Î¶¨Ïä§Ìä∏
                                    return List.copyOf(new LinkedHashSet<>(list));
                                }))
                ));

        long otherMembersCountIfAll = Math.max(0, base.size() - 1);

        // 3) DTOÏóê ratedUserIds / ratingSubmitted / progressPercent Ï£ºÏûÖ
        List<GroupMemberDetailDto> members = base.stream().map(m -> {
            int progressPercent = calcProgressPercent(m.maxReadPage(), pageCount);

            List<Long> ratedUserIds = fromToMap.getOrDefault(m.userId(), Collections.emptyList());
            boolean ratingSubmitted = (otherMembersCountIfAll > 0) && (ratedUserIds.size() == otherMembersCountIfAll);

            return new GroupMemberDetailDto(
                    m.userId(),
                    m.userNickName(),
                    m.profileColor(),
                    m.maxReadPage(),
                    progressPercent,
                    m.isHost(),
                    m.profileImageUrl(),
                    ratingSubmitted,
                    ratedUserIds
            );
        }).toList();

        boolean allReadCompleted = !members.isEmpty()
                && members.stream().allMatch(m -> m.progressPercent() >= 100);

        return new GroupDetailResponse(
                group.getRoomTitle(),
                group.getCategory().name(),
                group.getSchedule(),
                members.size(),
                group.getGroupMaxNum(),
                group.getDescription(),
                null,
                isHost,
                group.getMinRequiredRating(),
                pageCount,
                members,
                allReadCompleted
        );
    }

    @Override
    @Transactional
    public void deleteGroup(Long groupId, User user) {
        Group group = groupRepository.findById(groupId)
                .orElseThrow(() -> new NotFoundException("Í∑∏Î£πÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§."));
        if (!group.getHostUser().getId().equals(user.getId())) {
            throw new ForbiddenException("Í∑∏Î£π ÏÇ≠Ï†ú Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.");
        }
        groupNotificationScheduler.unregister(groupId);
        groupRepository.delete(group);
        log.info("üóëÔ∏è Í∑∏Î£π ÏÇ≠Ï†ú ÏôÑÎ£å Î∞è Ïä§ÏºÄÏ§Ñ Ìï¥Ï†ú: groupId={}", groupId);
    }

    @Override
    public List<GroupListResponseDto> searchGroups(String roomTitle, String category) {
        Group.Category categoryEnum = null;
        if (category != null && !category.isBlank()) {
            categoryEnum = Group.Category.valueOf(category.toUpperCase());
        }
        List<Group> groups = groupRepository.searchGroups(roomTitle, categoryEnum);
        return groups.stream().map(GroupListResponseDto::fromEntity).collect(Collectors.toList());
    }

    @Override
    @Transactional
    public void leaveGroup(Long groupId, User user) {
        Group group = groupRepository.findById(groupId)
                .orElseThrow(() -> new NotFoundException("Ìï¥Îãπ Í∑∏Î£πÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§."));

        GroupMember member = groupMemberRepository.findByGroupAndUser(group, user)
                .orElseThrow(() -> new BadRequestException("Ìï¥Îãπ Í∑∏Î£πÏóê Í∞ÄÏûÖÎêòÏñ¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§."));

        if (group.getHostUser().getId().equals(user.getId())) {
            throw new ForbiddenException("Í∑∏Î£πÏû•ÏùÄ ÏßÅÏ†ë ÌÉàÌá¥Ìï† Ïàò ÏóÜÏäµÎãàÎã§. Í∑∏Î£πÏû• Í∂åÌïú ÏúÑÏûÑ ÌõÑ ÌÉàÌá¥ÌïòÏÑ∏Ïöî.");
        }

        groupMemberRepository.delete(member);

        ChatRoom chatRoom = chatRoomRepository.findByGroupId(groupId)
                .orElseThrow(() -> new NotFoundException("Ï±ÑÌåÖÎ∞© ÏóÜÏùå"));

        ChatRoomMember chatRoomMember = chatRoomMemberRepository.findByChatRoomAndUser(chatRoom, user).orElse(null);

        if (chatRoomMember != null) {
            chatRoomMemberRepository.delete(chatRoomMember);
            chatRoom.setMemberCount(Math.max(0, chatRoom.getMemberCount() - 1));
            chatRoomRepository.save(chatRoom);

            log.info("[GroupService] userId={} Í∑∏Î£π {} ÌÉàÌá¥ Î∞è Ï±ÑÌåÖÎ∞© Î©§Î≤Ñ ÏÇ≠Ï†ú ÏôÑÎ£å, memberCount={}",
                    user.getId(), groupId, chatRoom.getMemberCount());
        }
    }

    @Override
    public boolean isMember(Long groupId, Long userId) {
        return groupMemberRepository.isMember(groupId, userId);
    }

    @Override
    public boolean isLeader(Long groupId, Long userId) {
        Group group = groupRepository.findById(groupId)
                .orElseThrow(() -> new NotFoundException("Ìï¥Îãπ Í∑∏Î£πÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§."));
        return group.getHostUser().getId().equals(userId);
    }

    @Override
    public int getLastPageRead(Long groupId, Long userId) {
        Group group = groupRepository.findById(groupId)
                .orElseThrow(() -> new NotFoundException("Í∑∏Î£πÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."));
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new NotFoundException("Ïú†Ï†ÄÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."));
        GroupMember member = groupMemberRepository.findByGroupAndUser(group, user)
                .orElseThrow(() -> new NotFoundException("Ìï¥Îãπ Í∑∏Î£π Î©§Î≤ÑÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."));
        return member.getMaxReadPage();
    }

    @Override
    public List<MyGroupSummaryDto> getMyGroupList(Long userId) {
        List<GroupMember> memberships = groupMemberRepository.findByUser_Id(userId);
        return memberships.stream()
                .map(GroupMember::getGroup)
                .distinct()
                .map(group -> new MyGroupSummaryDto(
                        group.getId(),
                        group.getRoomTitle(),
                        group.getDescription(),
                        null,
                        group.getCategory().name(),
                        group.getGroupMembers().size(),
                        group.getGroupMaxNum(),
                        group.getHostUser().getId().equals(userId)
                ))
                .collect(java.util.stream.Collectors.toList());
    }

    private int resolvePageCount(Group group) {
        if (group.getPdfFile() != null) return group.getPdfFile().getPageCnt();
        // totalPagesÍ∞Ä intÎ©¥ Í∑∏ÎåÄÎ°ú, IntegerÎ©¥ null Í∞ÄÎìú
        try { return group.getTotalPages(); } catch (NullPointerException e) { return 0; }
    }

    private static final Map<String, String> DAY_MAP = Map.of(
            "MON", "ÏõîÏöîÏùº",
            "TUE", "ÌôîÏöîÏùº",
            "WED", "ÏàòÏöîÏùº",
            "THU", "Î™©ÏöîÏùº",
            "FRI", "Í∏àÏöîÏùº",
            "SAT", "ÌÜ†ÏöîÏùº",
            "SUN", "ÏùºÏöîÏùº"
    );

    private String cronToReadable(String cron) {
        String[] parts = cron.split("\\s+");
        if (parts.length < 6) return cron;

        int minute = Integer.parseInt(parts[1]); // Î∂Ñ
        int hour = Integer.parseInt(parts[2]);   // Ïãú

        String ampm = (hour < 12) ? "Ïò§Ï†Ñ" : "Ïò§ÌõÑ";
        int displayHour = (hour == 0) ? 12 : (hour <= 12 ? hour : hour - 12);
        String dayKorean = DAY_MAP.getOrDefault(parts[5], parts[5]);

        if (minute == 0) {
            return String.format("Îß§Ï£º %s %s %dÏãú", dayKorean, ampm, displayHour);
        } else {
            return String.format("Îß§Ï£º %s %s %dÏãú %dÎ∂Ñ", dayKorean, ampm, displayHour, minute);
        }
    }

    private int calcProgressPercent(int maxReadPage, int pageCount) {
        if (pageCount <= 0) return 0;

        // Îã®Ïùº ÌéòÏù¥ÏßÄ Î¨∏ÏÑú: 0Î≤à ÌéòÏù¥ÏßÄÎßå Ï°¥Ïû¨
        if (pageCount == 1) {
            // maxReadPageÍ∞Ä 0 Ïù¥ÏÉÅÏù¥Î©¥ ÏùΩÏùÄ Í≤ÉÏúºÎ°ú Î≥¥Í≥† 100%
            return (maxReadPage >= 0) ? 100 : 0;
        }

        // Îã§Ï§ë ÌéòÏù¥ÏßÄ(0..pageCount-1)ÏóêÏÑú 0-basedÎ°ú Í≥ÑÏÇ∞
        int clamped = Math.min(Math.max(0, maxReadPage), pageCount - 1);
        double ratio = (double) clamped / (pageCount - 1);
        return (int) Math.round(ratio * 100.0);
    }


    @Transactional
    public void updateMemberMaxReadPage(Long groupId, Long userId, int newMaxReadPage) {
        Group group = groupRepository.findById(groupId)
                .orElseThrow(() -> new NotFoundException("Í∑∏Î£πÏù¥ Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§."));
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new NotFoundException("Ïú†Ï†ÄÍ∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§."));

        GroupMember gm = groupMemberRepository.findByGroupAndUser(group, user)
                .orElseThrow(() -> new NotFoundException("Í∑∏Î£π Î©§Î≤ÑÍ∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§."));

        int pageCount = resolvePageCount(group);
        int clamped = Math.min(Math.max(0, newMaxReadPage), Math.max(0, pageCount - 1));
        if (clamped < gm.getMaxReadPage()) {
            return; // ÏßÑÎèÑ Ïó≠Ìñâ Î∞©ÏßÄ ‚Üí Ï†ÄÏû•ÌïòÏßÄ ÏïäÍ≥† Ï¢ÖÎ£å
        }

        gm.setMaxReadPage(clamped);
        gm.setProgressPercent((float) calcProgressPercent(clamped, pageCount));

        groupMemberRepository.save(gm);
    }

    @Transactional(readOnly = true)
    public List<GroupMemberProgressDto> getGroupAllProgress(Long groupId, Long requesterId) {
        // Î≥¥Ïïà: ÏöîÏ≤≠ÏûêÍ∞Ä Ìï¥Îãπ Í∑∏Î£π Î©§Î≤ÑÏù∏ÏßÄ ÌôïÏù∏
        if (!groupMemberRepository.isMember(groupId, requesterId)) {
            throw new ForbiddenException("Ìï¥Îãπ Í∑∏Î£π Î©§Î≤ÑÍ∞Ä ÏïÑÎãôÎãàÎã§.");
        }
        return groupMemberRepository.findAllMemberProgressByGroupId(groupId);
    }


    @Override
    public List<CompletedBookDto> getCompletedBooks(Long userId) {
        List<CompletedBookRow> rows = groupMemberRepository.findCompletedBooksByUserIdNative(userId);
        return rows.stream()
                .map(r -> new CompletedBookDto(
                        r.getFileName(),
                        Group.Category.valueOf(r.getCategory())  // Î¨∏ÏûêÏó¥ ‚Üí Enum
                ))
                .toList();
    }

    private String createContentDispositionHeader(String filename, boolean isAttachment) {
        if (filename == null || filename.trim().isEmpty()) {
            filename = "document.pdf";
        }

        String disposition = isAttachment ? "attachment" : "inline";

        return disposition + "; filename*=UTF-8''" + URLEncoder.encode(filename, StandardCharsets.UTF_8);
    }

}

